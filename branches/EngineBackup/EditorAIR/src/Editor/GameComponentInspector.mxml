<?xml version="1.0" encoding="utf-8"?>
<mx:DataGrid xmlns:mx="http://www.adobe.com/2006/mxml"
	editable="true"
	itemEditBeginning="OnItemEditBeginning(event);"
	itemEditBegin="OnItemEditBegin(event);"
	itemEditEnd="OnItemEditEnd(event);"
	creationComplete="OnComplete(event);"
	width="100%">
	<mx:columns>
     	<mx:DataGridColumn headerText="Nombre" dataField="Key" width="100" editable="false"/>
     	<mx:DataGridColumn headerText="Valor" dataField="Value" width="100" editable="true"/>
     </mx:columns>

	<mx:Script>
		<![CDATA[
			import GameComponents.DefaultGameComponent;
			import GameComponents.GameComponent;
			
			import Model.AssetObject;
			import Model.SceneObject;
			
			import mx.binding.utils.BindingUtils;
			import mx.binding.utils.ChangeWatcher;
			import mx.collections.ArrayCollection;
			import mx.collections.Sort;
			import mx.collections.SortField;
			import mx.controls.Menu;
			import mx.controls.NumericStepper;
			import mx.controls.TextInput;
			import mx.events.DataGridEvent;
			import mx.events.DataGridEventReason;
			import mx.events.FlexEvent;
			import mx.managers.IFocusManagerComponent;
			
			import utils.Delegate;
			import utils.KeyValueWrapper;
			import utils.Point3;


		public function Init(controller : EditorController, gameComponent : GameComponent) : void
		{
			mController = controller;
			mGameComponent = gameComponent;

			var theFields : ArrayCollection = mGameComponent.ReflectGameComponent(); 
			
			var theSort : Sort = new Sort();
			theSort.fields = [new SortField("ValueType",true), new SortField("Key",true, true) ]
			theFields.sort = theSort;
			theSort.reverse();
			theFields.refresh();
			
			dataProvider = theFields; 

			this.showHeaders = false;
			this.height = dataProvider.length*(this.rowHeight+5) + 3; // + this.headerHeight;

			for each(var wrap : KeyValueWrapper in dataProvider)
			{
				var varName:String = wrap.Key;
				var newWatcher : ChangeWatcher = BindingUtils.bindSetter(Delegate.create(OnPropChanged, wrap), mGameComponent, varName);
				mWatchers.push(newWatcher);
			}

			// Hay q subscribirse al padre para que el sistema te lo mande
			parent.addEventListener(Event.REMOVED, OnRemoved, false, 0, true);
		}

		private function OnComplete(event:Event):void
		{
			addEventListener(FocusEvent.FOCUS_OUT, OnFocusOut);
			addEventListener(FocusEvent.FOCUS_IN, OnFocusIn);
		}

		private function OnFocusIn(event:FocusEvent):void
		{
			// A veces el otro Inspector no recibe el out, así que para evitar que se ilumen varios...
			if (event.relatedObject is GameComponentInspector)
				(event.relatedObject as GameComponentInspector).selectedIndex = -1;
		}

		private function OnFocusOut(event:FocusEvent):void
		{
			if ((event.relatedObject == null) || !IsChild(event.relatedObject))
			{
				// Cuando seleccionan por ejemplo otro GameComponentInspector, nosotros dejamos de mostrar row azul seleccionada
				this.selectedIndex = -1;

				// Cuando nos vamos a un menu, la proxima vez q nos dan el foco rechazamos!
				if (event.relatedObject is Menu)
					mRejectEdition = true;
			}
		}

		private function IsChild(other : DisplayObject):Boolean
		{
			var current : DisplayObject = other.parent;

			while (current != this && current != stage)
				current = current.parent;

			return current != stage;
		}

		private function OnRemoved(event:Event):void
		{
			if (event.target != parent)
				return;

			parent.removeEventListener(Event.REMOVED, OnRemoved);

			for each(var watcher : ChangeWatcher in mWatchers)
			{
				watcher.unwatch();
			}
			mWatchers = null;
		}


		private function OnPropChanged(prop:Object, wrap:KeyValueWrapper):void
		{
			dataProvider.itemUpdated(wrap);
		}


		private function OnItemEditBeginning(event:DataGridEvent):void
		{
			if (mRejectEdition)
			{
				mRejectEdition = false;
				event.preventDefault();
				return;
			}

			// Prevención de edición. El nombre del movieclip asociado al DefaultGameComponent no se edita
			// TODO: Estaría bien q esto fuera una propiedad de la variable. Si no es writable, no se devuelve en
			// ReflectGameComponent, pero se debería devolver y decidir aquí (necesitaríamos un "visible" pero no "editable")
			if ((mGameComponent is DefaultGameComponent) && dataProvider[event.rowIndex].Key == "MovieClipName")
			{
				event.preventDefault();
			}
		}

		private function OnItemEditBegin(event:DataGridEvent):void
		{
			var varName : String = dataProvider[event.rowIndex].Key;

			if (mGameComponent[varName] is Boolean)
			{
				CreateBooleanEditor(varName, event);
			}
			else
			if (mGameComponent[varName] is Number)
			{
				CreateInputTextItemEditor(varName, event, "value");
			}
			else
			{
				CreateInputTextItemEditor(varName, event, "text");
			}
		}

		private function CreateBooleanEditor(varName : String, event:DataGridEvent):void
		{
			event.preventDefault();

			var theClassFactory : ClassFactory = new ClassFactory(BooleanItemEditor);
			theClassFactory.properties = { data:mGameComponent[varName] };

			columns[event.columnIndex].itemEditor = theClassFactory;
			createItemEditor(event.columnIndex, event.rowIndex);
		}

		private function CreateInputTextItemEditor(varName : String, event:DataGridEvent, paramEditorDataField : String) : void
		{
			event.preventDefault();

			var theClassFactory : ClassFactory = new ClassFactory(mx.controls.TextInput);
			
			columns[event.columnIndex].itemEditor = theClassFactory;
			columns[event.columnIndex].editorDataField = paramEditorDataField;

			createItemEditor(event.columnIndex, event.rowIndex);

			var theItemEditor : TextInput = itemEditorInstance as TextInput;
			
			theItemEditor.data = mGameComponent[varName];
			theItemEditor.selectionBeginIndex = 0;
			theItemEditor.selectionEndIndex = theItemEditor.text.length;
			
			this.focusManager.setFocus(theItemEditor);
		}

		private function OnItemEditEnd(event:DataGridEvent):void
		{
			var varName : String = dataProvider[event.rowIndex].Key;

			if (event.reason == DataGridEventReason.CANCELLED)
                return;

			if (mGameComponent[varName] is Boolean)
			{
				event.preventDefault();

				var boolEditor : BooleanItemEditor = this.itemEditorInstance as BooleanItemEditor;
				if (boolEditor.selectedItem == "true")
					dataProvider[event.rowIndex].Value = true;
				else
					dataProvider[event.rowIndex].Value = false;

				dataProvider.itemUpdated(dataProvider[event.rowIndex]);
				destroyItemEditor();
				updateList();
			}
			else
			if (mGameComponent[varName] is String)
			{
				event.preventDefault();
				dataProvider[event.rowIndex].Value = (itemEditorInstance as TextInput).text;;
				dataProvider.itemUpdated(dataProvider[event.rowIndex]);
				destroyItemEditor();
			}
			else
			if (mGameComponent[varName] is Number)
			{
				event.preventDefault();

				var daText : String = (itemEditorInstance as TextInput).text;
				var parsedFloat : Number = parseFloat(daText);

				if (!isNaN(parsedFloat))
					dataProvider[event.rowIndex].Value = parsedFloat;

				dataProvider.itemUpdated(dataProvider[event.rowIndex]);
				destroyItemEditor();
			}
			else
			if (mGameComponent[varName] is Point3)
			{
				event.preventDefault();

				// Parseamos el potencial Point3 que el usuario ha escrito y lo guardamos en el Value
				var parsedPoint3 : Point3 = Point3.Point3FromString((itemEditorInstance as TextInput).text);

				if (parsedPoint3 != null)
				{
					dataProvider[event.rowIndex].Value = parsedPoint3;
					dataProvider.itemUpdated(dataProvider[event.rowIndex]);
				}
				destroyItemEditor();
			}
			else
			if (mGameComponent[varName] is Point)
			{
				event.preventDefault();

				// Parseamos el potencial Point que el usuario ha escrito y lo guardamos en el Value
				var parsedPoint : Point = Point3.PointFromString((itemEditorInstance as TextInput).text);

				if (parsedPoint != null)
				{
					dataProvider[event.rowIndex].Value = parsedPoint;
					dataProvider.itemUpdated(dataProvider[event.rowIndex]);
				}
				destroyItemEditor();
			}
		}

		private var mController : EditorController;
		private var mGameComponent : GameComponent;

		private var mWatchers : Array = new Array();

		private var mRejectEdition : Boolean = false;
		]]>
	</mx:Script>


</mx:DataGrid>



<!--
	/*
			var stepSize : Number = 1;
			var maximum : Number = 9999;
			var minimum : Number = -9999;

			if (mGameComponent.hasOwnProperty(varName+"StepSize"))
				stepSize = mGameComponent[varName+"StepSize"];

			if (mGameComponent.hasOwnProperty(varName+"Maximum"))
				maximum = mGameComponent[varName+"Maximum"];

			if (mGameComponent.hasOwnProperty(varName+"Minimum"))
				minimum = mGameComponent[varName+"Minimum"];

			theClassFactory.properties = { data:mGameComponent[varName], stepSize:stepSize, maximum:maximum, minimum:minimum};
	*/
-->